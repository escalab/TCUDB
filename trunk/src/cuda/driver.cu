/* This file is generated by code_gen.py */
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>
#include <malloc.h>
#include <time.h>
#include <getopt.h>
#include <linux/limits.h>
#include "../include/common.h"
#include "../include/hashJoin.h"
#include "../include/schema.h"
#include "../include/cpuCudaLib.h"
#include "../include/gpuCudaLib.h"
extern struct tableNode* tableScan(struct scanNode *,struct statistic *);
extern struct tableNode* hashJoin(struct joinNode *, struct statistic *);
extern struct tableNode* groupBy(struct groupByNode *,struct statistic *);
extern struct tableNode* orderBy(struct orderByNode *, struct statistic *);
extern char* materializeCol(struct materializeNode * mn, struct statistic *);
#define CHECK_POINTER(p) do {\
	if(p == NULL){   \
		perror("Failed to allocate host memory");    \
		exit(-1);      \
	}} while(0)
int main(int argc, char ** argv){

/* For initializing CUDA device */
	int * cudaTmp;
	cudaMalloc((void**)&cudaTmp,sizeof(int));
	cudaFree(cudaTmp);

	int table;
	int long_index;
	char path[PATH_MAX];
	int setPath = 0;
	struct option long_options[] = {
		{"datadir",required_argument,0,'0'}
	};

	while((table=getopt_long(argc,argv,"",long_options,&long_index))!=-1){
		switch(table){
			case '0':
				setPath = 1;
				strcpy(path,optarg);
				break;
		}
	}

	if(setPath == 1)
		chdir(path);

	struct timespec start,end;
	struct timespec diskStart, diskEnd;
	double diskTotal = 0;
	clock_gettime(CLOCK_REALTIME,&start);
	struct statistic pp;
	pp.total = pp.kernel = pp.pcie = 0;
	struct tableNode *result = (struct tableNode*) malloc(sizeof(struct tableNode));
	CHECK_POINTER(result);
	initTable(result);
	struct tableNode *mat2Table;
	int outFd;
	long outSize;
	char *outTable;
	long offset, tupleOffset;
	int blockTotal;
	struct columnHeader header;

	outFd = open("MAT21",O_RDONLY);
	read(outFd,&header, sizeof(struct columnHeader));
	blockTotal = header.blockTotal;
	close(outFd);
	offset=0;
	tupleOffset=0;
	struct tableNode *mat2Res = (struct tableNode *)malloc(sizeof(struct tableNode));
	CHECK_POINTER(mat2Res);
	initTable(mat2Res);
	for(int i=0;i<blockTotal;i++){
		mat2Table = (struct tableNode *) malloc(sizeof(struct tableNode));
		CHECK_POINTER(mat2Table);
		mat2Table->totalAttr = 3;
		mat2Table->attrType = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(mat2Table->attrType);
		mat2Table->attrSize = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(mat2Table->attrSize);
		mat2Table->attrIndex = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(mat2Table->attrIndex);
		mat2Table->attrTotalSize = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(mat2Table->attrTotalSize);
		mat2Table->dataPos = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(mat2Table->dataPos);
		mat2Table->dataFormat = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(mat2Table->dataFormat);
		mat2Table->content = (char **) malloc(sizeof(char *)*3);
		CHECK_POINTER(mat2Table->content);
		mat2Table->attrSize[0] = sizeof(int);
		mat2Table->attrIndex[0] = 1;
		mat2Table->attrType[0] = INT;
		mat2Table->dataPos[0] = MEM;
		outFd = open("MAT21",O_RDONLY);
		offset = i * sizeof(struct columnHeader) + tupleOffset *sizeof(int);
		lseek(outFd,offset,SEEK_SET);
		read(outFd,&header, sizeof(struct columnHeader));
		offset += sizeof(struct columnHeader);
		mat2Table->dataFormat[0] = header.format;
		outSize = header.tupleNum * sizeof(int);
		mat2Table->attrTotalSize[0] = outSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable =(char *) mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);

		mat2Table->content[0] = (char *)memalign(256,outSize);
		memcpy(mat2Table->content[0],outTable,outSize);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		mat2Table->attrSize[1] = sizeof(int);
		mat2Table->attrIndex[1] = 2;
		mat2Table->attrType[1] = INT;
		mat2Table->dataPos[1] = MEM;
		outFd = open("MAT22",O_RDONLY);
		offset = i * sizeof(struct columnHeader) + tupleOffset *sizeof(int);
		lseek(outFd,offset,SEEK_SET);
		read(outFd,&header, sizeof(struct columnHeader));
		offset += sizeof(struct columnHeader);
		mat2Table->dataFormat[1] = header.format;
		outSize = header.tupleNum * sizeof(int);
		mat2Table->attrTotalSize[1] = outSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable =(char *) mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);

		mat2Table->content[1] = (char *)memalign(256,outSize);
		memcpy(mat2Table->content[1],outTable,outSize);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		mat2Table->attrSize[2] = sizeof(int);
		mat2Table->attrIndex[2] = 0;
		mat2Table->attrType[2] = INT;
		mat2Table->dataPos[2] = MEM;
		outFd = open("MAT20",O_RDONLY);
		offset = i * sizeof(struct columnHeader) + tupleOffset *sizeof(int);
		lseek(outFd,offset,SEEK_SET);
		read(outFd,&header, sizeof(struct columnHeader));
		offset += sizeof(struct columnHeader);
		mat2Table->dataFormat[2] = header.format;
		outSize = header.tupleNum * sizeof(int);
		mat2Table->attrTotalSize[2] = outSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable =(char *) mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);

		mat2Table->content[2] = (char *)memalign(256,outSize);
		memcpy(mat2Table->content[2],outTable,outSize);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		mat2Table->tupleSize = 0 + sizeof(int) + sizeof(int) + sizeof(int) + sizeof(int);

		mat2Table->tupleNum = header.tupleNum;
		if(blockTotal != 1){
			mergeIntoTable(mat2Res,mat2Table,&pp);
			clock_gettime(CLOCK_REALTIME,&diskStart);
			freeTable(mat2Table);
			clock_gettime(CLOCK_REALTIME,&diskEnd);
			diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		}else{
			free(mat2Res);
			mat2Res = mat2Table;
		}
		tupleOffset += header.tupleNum;

	}

	outFd = open("MAT10",O_RDONLY);
	read(outFd, &header, sizeof(struct columnHeader));
	blockTotal = header.blockTotal;
	close(outFd);
	offset = 0;
	long blockSize[3];
	for(int i=0;i<3;i++)
		blockSize[i] = 0;
	for(int i=0;i<blockTotal;i++){

		struct tableNode *mat1Table = (struct tableNode*)malloc(sizeof(struct tableNode));
		CHECK_POINTER(mat1Table);
		mat1Table->totalAttr = 3;
		mat1Table->attrType = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(mat1Table->attrType);
		mat1Table->attrSize = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(mat1Table->attrSize);
		mat1Table->attrIndex = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(mat1Table->attrIndex);
		mat1Table->attrTotalSize = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(mat1Table->attrTotalSize);
		mat1Table->dataPos = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(mat1Table->dataPos);
		mat1Table->dataFormat = (int *) malloc(sizeof(int)*3);
		CHECK_POINTER(mat1Table->dataFormat);
		mat1Table->content = (char **) malloc(sizeof(char *)*3);
		CHECK_POINTER(mat1Table->content);
		mat1Table->attrType[0] = INT;
		mat1Table->attrSize[0] = sizeof(int);
		mat1Table->attrIndex[0] = 0;
		mat1Table->dataPos[0] = MEM;
		outFd = open("MAT10", O_RDONLY);
		offset = i*sizeof(struct columnHeader) + blockSize[0];
		lseek(outFd,offset,SEEK_SET);
		read(outFd, &header, sizeof(struct columnHeader));
		blockSize[0] += header.blockSize;
		offset += sizeof(struct columnHeader);
		mat1Table->dataFormat[0] = header.format;
		outSize = header.blockSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		mat1Table->content[0] = (char *)malloc(outSize);

		CHECK_POINTER(mat1Table->content[0]);
		memcpy(mat1Table->content[0],outTable,outSize);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		mat1Table->attrTotalSize[0] = outSize;
		mat1Table->attrType[1] = INT;
		mat1Table->attrSize[1] = sizeof(int);
		mat1Table->attrIndex[1] = 2;
		mat1Table->dataPos[1] = MEM;
		outFd = open("MAT12", O_RDONLY);
		offset = i*sizeof(struct columnHeader) + blockSize[1];
		lseek(outFd,offset,SEEK_SET);
		read(outFd, &header, sizeof(struct columnHeader));
		blockSize[1] += header.blockSize;
		offset += sizeof(struct columnHeader);
		mat1Table->dataFormat[1] = header.format;
		outSize = header.blockSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		mat1Table->content[1] = (char *)malloc(outSize);

		CHECK_POINTER(mat1Table->content[1]);
		memcpy(mat1Table->content[1],outTable,outSize);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		mat1Table->attrTotalSize[1] = outSize;
		mat1Table->attrType[2] = INT;
		mat1Table->attrSize[2] = sizeof(int);
		mat1Table->attrIndex[2] = 1;
		mat1Table->dataPos[2] = MEM;
		outFd = open("MAT11", O_RDONLY);
		offset = i*sizeof(struct columnHeader) + blockSize[2];
		lseek(outFd,offset,SEEK_SET);
		read(outFd, &header, sizeof(struct columnHeader));
		blockSize[2] += header.blockSize;
		offset += sizeof(struct columnHeader);
		mat1Table->dataFormat[2] = header.format;
		outSize = header.blockSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		mat1Table->content[2] = (char *)malloc(outSize);

		CHECK_POINTER(mat1Table->content[2]);
		memcpy(mat1Table->content[2],outTable,outSize);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		mat1Table->attrTotalSize[2] = outSize;
		mat1Table->tupleSize = 0 + sizeof(int) + sizeof(int) + sizeof(int);

		mat1Table->tupleNum = header.tupleNum;
		struct tableNode * mat1Res = mat1Table;
		struct joinNode jNode0;
		jNode0.leftTable = mat1Res;
		jNode0.rightTable = mat2Res;
		jNode0.totalAttr = 4;
		jNode0.keepInGpu = (int *) malloc(sizeof(int) * 4);
		CHECK_POINTER(jNode0.keepInGpu);
		for(int k=0;k<4;k++)
			jNode0.keepInGpu[k] = 1;
		jNode0.rightOutputAttrNum = 2;
		jNode0.leftOutputAttrNum = 2;
		jNode0.leftOutputAttrType = (int *)malloc(sizeof(int)*2);
		CHECK_POINTER(jNode0.leftOutputAttrType);
		jNode0.leftOutputIndex = (int *)malloc(sizeof(int)*2);
		CHECK_POINTER(jNode0.leftOutputIndex);
		jNode0.leftPos = (int *)malloc(sizeof(int)*2);
		CHECK_POINTER(jNode0.leftPos);
		jNode0.tupleSize = 0;
		jNode0.leftOutputIndex[0] = 0;
		jNode0.leftOutputAttrType[0] = INT;
		jNode0.leftPos[0] = 0;
		jNode0.tupleSize += mat1Res->attrSize[0];
		jNode0.leftOutputIndex[1] = 1;
		jNode0.leftOutputAttrType[1] = INT;
		jNode0.leftPos[1] = 2;
		jNode0.tupleSize += mat1Res->attrSize[1];
		jNode0.rightOutputAttrType = (int *)malloc(sizeof(int)*2);
		CHECK_POINTER(jNode0.rightOutputAttrType);
		jNode0.rightOutputIndex = (int *)malloc(sizeof(int)*2);
		CHECK_POINTER(jNode0.rightOutputIndex);
		jNode0.rightPos = (int *)malloc(sizeof(int)*2);
		CHECK_POINTER(jNode0.rightPos);
		jNode0.rightOutputIndex[0] = 0;
		jNode0.rightOutputAttrType[0] = INT;
		jNode0.rightPos[0] = 1;
		jNode0.tupleSize += mat2Res->attrSize[0];
		jNode0.rightOutputIndex[1] = 1;
		jNode0.rightOutputAttrType[1] = INT;
		jNode0.rightPos[1] = 3;
		jNode0.tupleSize += mat2Res->attrSize[1];
		jNode0.rightKeyIndex = 2;
		jNode0.leftKeyIndex = 2;
		struct tableNode *join0 = hashJoin(&jNode0,&pp);

		if(blockTotal !=1){
			mergeIntoTable(result,join0, &pp);
			clock_gettime(CLOCK_REALTIME,&diskStart);
			freeTable(join0);
			clock_gettime(CLOCK_REALTIME,&diskEnd);
			diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		}else{
			clock_gettime(CLOCK_REALTIME,&diskStart);
			freeTable(result);
			result = join0;
			clock_gettime(CLOCK_REALTIME,&diskEnd);
			diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		}
	}

	struct groupByNode * gbNode = (struct groupByNode *) malloc(sizeof(struct groupByNode));
	CHECK_POINTER(gbNode);
	gbNode->table = result;
	gbNode->groupByColNum = 2;
	gbNode->groupByIndex = (int *)malloc(sizeof(int) * 2);
	CHECK_POINTER(gbNode->groupByIndex);
	gbNode->groupByType = (int *)malloc(sizeof(int) * 2);
	CHECK_POINTER(gbNode->groupByType);
	gbNode->groupBySize = (int *)malloc(sizeof(int) * 2);
	CHECK_POINTER(gbNode->groupBySize);
	gbNode->groupByIndex[0] = 0;
	gbNode->groupByType[0] = gbNode->table->attrType[0];
	gbNode->groupBySize[0] = gbNode->table->attrSize[0];
	gbNode->groupByIndex[1] = 1;
	gbNode->groupByType[1] = gbNode->table->attrType[1];
	gbNode->groupBySize[1] = gbNode->table->attrSize[1];
	gbNode->outputAttrNum = 3;
	gbNode->attrType = (int *) malloc(sizeof(int) *3);
	CHECK_POINTER(gbNode->attrType);
	gbNode->attrSize = (int *) malloc(sizeof(int) *3);
	CHECK_POINTER(gbNode->attrSize);
	gbNode->tupleSize = 0;
	gbNode->gbExp = (struct groupByExp *) malloc(sizeof(struct groupByExp) * 3);
	CHECK_POINTER(gbNode->gbExp);
	gbNode->attrType[0] = result->attrType[0];
	gbNode->attrSize[0] = result->attrSize[0];
	gbNode->tupleSize += result->attrSize[0];
	gbNode->gbExp[0].func = NOOP;
	gbNode->gbExp[0].exp.op = NOOP;
	gbNode->gbExp[0].exp.exp = NULL;
	gbNode->gbExp[0].exp.opNum = 1;
	gbNode->gbExp[0].exp.opType = COLUMN;
	gbNode->gbExp[0].exp.opValue = 0;
	gbNode->attrType[1] = result->attrType[1];
	gbNode->attrSize[1] = result->attrSize[1];
	gbNode->tupleSize += result->attrSize[1];
	gbNode->gbExp[1].func = NOOP;
	gbNode->gbExp[1].exp.op = NOOP;
	gbNode->gbExp[1].exp.exp = NULL;
	gbNode->gbExp[1].exp.opNum = 1;
	gbNode->gbExp[1].exp.opType = COLUMN;
	gbNode->gbExp[1].exp.opValue = 1;
	gbNode->tupleSize += sizeof(float);
	gbNode->attrType[2] = FLOAT;
	gbNode->attrSize[2] = sizeof(float);
	gbNode->gbExp[2].func = SUM;
	gbNode->gbExp[2].exp.op = MULTIPLY;
	gbNode->gbExp[2].exp.opNum = 2;
	gbNode->gbExp[2].exp.exp = (long) malloc(sizeof(struct mathExp) * 2);
((struct mathExp *)	gbNode->gbExp[2].exp.exp)[0].op = NOOP;
((struct mathExp *)	gbNode->gbExp[2].exp.exp)[0].opNum = 1;
((struct mathExp *)	gbNode->gbExp[2].exp.exp)[0].exp = 0;
((struct mathExp *)	gbNode->gbExp[2].exp.exp)[0].opType = COLUMN;
((struct mathExp *)	gbNode->gbExp[2].exp.exp)[0].opValue = 2;
((struct mathExp *)	gbNode->gbExp[2].exp.exp)[1].op = NOOP;
((struct mathExp *)	gbNode->gbExp[2].exp.exp)[1].opNum = 1;
((struct mathExp *)	gbNode->gbExp[2].exp.exp)[1].exp = 0;
((struct mathExp *)	gbNode->gbExp[2].exp.exp)[1].opType = COLUMN;
((struct mathExp *)	gbNode->gbExp[2].exp.exp)[1].opValue = 3;
	struct tableNode * gbResult = groupBy(gbNode, &pp);
	freeGroupByNode(gbNode);

	struct materializeNode mn;
	mn.table = gbResult;
	materializeCol(&mn, &pp);
	freeTable(gbResult);

	clock_gettime(CLOCK_REALTIME,&end);
	double timeE = (end.tv_sec -  start.tv_sec)* BILLION + end.tv_nsec - start.tv_nsec;
	printf("Disk Load Time: %lf\n", diskTotal/(1000*1000));
	printf("PCIe Time: %lf\n",pp.pcie);
	printf("Kernel Time: %lf\n",pp.kernel);
	printf("Total Time: %lf\n", timeE/(1000*1000));
}

