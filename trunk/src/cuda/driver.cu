/* This file is generated by code_gen.py */
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>
#include <malloc.h>
#include <time.h>
#include <getopt.h>
#include <linux/limits.h>
#include "../include/common.h"
#include "../include/hashJoin.h"
#include "../include/schema.h"
#include "../include/cpuCudaLib.h"
#include "../include/gpuCudaLib.h"
#include "../include/cuPrintf.cu"
#include "../include/cuPrintf.cuh"
extern struct tableNode* tableScan(struct scanNode *,struct statistic *);
extern struct tableNode* hashJoin(struct joinNode *, struct statistic *);
extern struct tableNode* groupBy(struct groupByNode *,struct statistic *);
extern struct tableNode* orderBy(struct orderByNode *, struct statistic *);
extern char* materializeCol(struct materializeNode * mn, struct statistic *);
#define CHECK_POINTER(p) do {\
	if(p == NULL){   \
		perror("Failed to allocate host memory");    \
		exit(-1);      \
	}} while(0)
int main(int argc, char ** argv){

//        cudaPrintfInit();
//        cudaPrintfDisplay(stdout, true);
/* For initializing CUDA device */
	int * cudaTmp;
	cudaMalloc((void**)&cudaTmp,sizeof(int));
	cudaFree(cudaTmp);

	int table;
	int long_index;
	char path[PATH_MAX];
	int setPath = 0;
	struct option long_options[] = {
		{"datadir",required_argument,0,'0'}
	};

	while((table=getopt_long(argc,argv,"",long_options,&long_index))!=-1){
		switch(table){
			case '0':
				setPath = 1;
				strcpy(path,optarg);
				break;
		}
	}

	if(setPath == 1)
		chdir(path);

	struct timespec start,end;
	struct timespec diskStart, diskEnd;
	double diskTotal = 0;
	clock_gettime(CLOCK_REALTIME,&start);
	struct statistic pp;
	pp.total = pp.kernel = pp.pcie = 0;
	struct tableNode *result = (struct tableNode*) malloc(sizeof(struct tableNode));
	CHECK_POINTER(result);
	initTable(result);
	int outFd;
	long outSize;
	char *outTable;
	long offset, tupleOffset;
	int blockTotal;
	struct columnHeader header;

	outFd = open("MATRICES3",O_RDONLY);
	read(outFd, &header, sizeof(struct columnHeader));
	blockTotal = header.blockTotal;
        printf("blockTotal is: %d\n", blockTotal);
	close(outFd);
	offset = 0;
	long blockSize[2];
	for(int i=0;i<2;i++)
		blockSize[i] = 0;
	for(int i=0;i<blockTotal;i++){

		struct tableNode *matricesTable = (struct tableNode*)malloc(sizeof(struct tableNode));
		CHECK_POINTER(matricesTable);
		matricesTable->totalAttr = 2;
		matricesTable->attrType = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(matricesTable->attrType);
		matricesTable->attrSize = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(matricesTable->attrSize);
		matricesTable->attrIndex = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(matricesTable->attrIndex);
		matricesTable->attrTotalSize = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(matricesTable->attrTotalSize);
		matricesTable->dataPos = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(matricesTable->dataPos);
		matricesTable->dataFormat = (int *) malloc(sizeof(int)*2);
		CHECK_POINTER(matricesTable->dataFormat);
		matricesTable->content = (char **) malloc(sizeof(char *)*2);
		CHECK_POINTER(matricesTable->content);
		matricesTable->attrType[0] = INT;
		matricesTable->attrSize[0] = sizeof(int);
		matricesTable->attrIndex[0] = 3;
		matricesTable->dataPos[0] = MEM;
		outFd = open("MATRICES3", O_RDONLY);
		offset = i*sizeof(struct columnHeader) + blockSize[0];
		lseek(outFd,offset,SEEK_SET);
		read(outFd, &header, sizeof(struct columnHeader));
		blockSize[0] += header.blockSize;
		offset += sizeof(struct columnHeader);
		matricesTable->dataFormat[0] = header.format;
		outSize = header.blockSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		matricesTable->content[0] = (char *)malloc(outSize);

		CHECK_POINTER(matricesTable->content[0]);
		memcpy(matricesTable->content[0],outTable,outSize);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		matricesTable->attrTotalSize[0] = outSize;
		matricesTable->attrType[1] = INT;
		matricesTable->attrSize[1] = sizeof(int);
		matricesTable->attrIndex[1] = 0;
		matricesTable->dataPos[1] = MEM;
		outFd = open("MATRICES0", O_RDONLY);
		offset = i*sizeof(struct columnHeader) + blockSize[1];
		lseek(outFd,offset,SEEK_SET);
		read(outFd, &header, sizeof(struct columnHeader));
		blockSize[1] += header.blockSize;
		offset += sizeof(struct columnHeader);
		matricesTable->dataFormat[1] = header.format;
		outSize = header.blockSize;
		clock_gettime(CLOCK_REALTIME,&diskStart);
		outTable = (char *)mmap(0,outSize,PROT_READ,MAP_SHARED,outFd,offset);
		matricesTable->content[1] = (char *)malloc(outSize);

		CHECK_POINTER(matricesTable->content[1]);
		memcpy(matricesTable->content[1],outTable,outSize);
		munmap(outTable,outSize);
		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		close(outFd);
		matricesTable->attrTotalSize[1] = outSize;
		matricesTable->tupleSize = 0 + sizeof(int) + sizeof(int);

		matricesTable->tupleNum = header.tupleNum;
		struct scanNode matricesRel;
		matricesRel.tn = matricesTable;
		matricesRel.hasWhere = 1;
		matricesRel.whereAttrNum = 1;
		matricesRel.outputNum = 1;
		matricesRel.whereIndex = (int *)malloc(sizeof(int)*1);
		CHECK_POINTER(matricesRel.whereIndex);
		matricesRel.outputIndex = (int *)malloc(sizeof(int)*1);
		CHECK_POINTER(matricesRel.outputIndex);
		matricesRel.whereIndex[0] = 1;
		matricesRel.outputIndex[0 ] = 0;
		matricesRel.keepInGpu = 1;
		matricesRel.filter = (struct whereCondition *)malloc(sizeof(struct whereCondition));
		CHECK_POINTER(matricesRel.filter);
		(matricesRel.filter)->nested = 0;
		(matricesRel.filter)->expNum = 1;
		(matricesRel.filter)->exp = (struct whereExp*) malloc(sizeof(struct whereExp) *1);
		CHECK_POINTER((matricesRel.filter)->exp);
		(matricesRel.filter)->andOr = EXP;
		(matricesRel.filter)->exp[0].index = 0;
		(matricesRel.filter)->exp[0].relation = EQ;
		{
			int tmp = 1;
			memcpy((matricesRel.filter)->exp[0].content, &tmp,sizeof(int));
		}
//                cuPrintf("whereCondition content: %s\n", (matricesRel.filter)->exp->content);
                //printf("whereCondition content: %s\n", (matricesRel.filter)->exp->content);
		struct tableNode * matricesRes = tableScan(&matricesRel, &pp);
		if(blockTotal !=1){
			mergeIntoTable(result,matricesRes,&pp);
		}else{
			clock_gettime(CLOCK_REALTIME,&diskStart);
                        // print result to verify the correctness
			freeTable(result);
			result = matricesRes;
			clock_gettime(CLOCK_REALTIME,&diskEnd);
			diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
		}
		clock_gettime(CLOCK_REALTIME,&diskStart);
		freeScan(&matricesRel);

		clock_gettime(CLOCK_REALTIME,&diskEnd);
		diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
	}

        printf("====Result====\n");
        printf("dataPos: %d\n", result->dataPos);
	struct materializeNode mn;
	mn.table = result;
	materializeCol(&mn, &pp);
	freeTable(result);

	clock_gettime(CLOCK_REALTIME,&end);
	double timeE = (end.tv_sec -  start.tv_sec)* BILLION + end.tv_nsec - start.tv_nsec;
	printf("Disk Load Time: %lf\n", diskTotal/(1000*1000));
	printf("PCIe Time: %lf\n",pp.pcie);
	printf("Kernel Time: %lf\n",pp.kernel);
	printf("Total Time: %lf\n", timeE/(1000*1000));
        cudaPrintfEnd();
}

